#! /usr/bin/python

'''
    Padding Oracle Attack implementation of this article https://not.burntout.org/blog/Padding_Oracle_Attack/
    Check the readme for a full cryptographic explanation
    Author: mpgn <martial.puygrenier@gmail.com>
    Date: 2016
'''

import argparse
import httplib, urllib
import re
import binascii
import sys
import time
from binascii import unhexlify, hexlify
from itertools import cycle, izip
from pwn import *

def call_oracle(up_cipher, p):
    print p.recvuntil(":")
    p.sendline(up_cipher)
    print "Sending message..."
    response = p.recvline()
    print response
    if response.find("yep") != -1:
        return 1
    else:
        return 0

def split_len(seq, length):
    return [seq[i:i+length] for i in range(0, len(seq), length)]

''' create custom block for the byte we search'''
def block_search_byte(size_block, i, pos, l):
    hex_char = hex(pos).split('0x')[1]
    return "00"*(size_block-(i+1)) + ("0" if len(hex_char)%2 != 0 else '') + hex_char + ''.join(l)    

''' create custom block for the padding'''
def block_padding(size_block, i):
    l = []
    for t in range(0,i+1):
        l.append(("0" if len(hex(i+1).split('0x')[1])%2 != 0 else '') + (hex(i+1).split('0x')[1]))
    return "00"*(size_block-(i+1)) + ''.join(l)

def hex_xor(s1,s2):
    return hexlify(''.join(chr(ord(c1) ^ ord(c2)) for c1, c2 in zip(unhexlify(s1), cycle(unhexlify(s2)))))

def run(cipher,size_block, process):
    cipher       = cipher.upper()
    found= False
    valide_value = []
    result       = []
    len_block    = size_block*2
    cipher_block = split_len(cipher, len_block)

    if len(cipher_block) == 1:
        print "[-] Abort there is only one block"
        sys.exit()  
    #for each cipher_block
    for block in reversed(range(1,len(cipher_block))):
        if len(cipher_block[block]) != len_block:
            print "[-] Abort length block doesn't match the size_block"
            break
        print "[+] Search value block : ", block, "\n"
        #for each byte of the block
        for i in range(0,size_block):
            # test each byte max 255
            for ct_pos in range(0,256):
                # 1 xor 1 = 0 or valide padding need to be checked
                if ct_pos != i+1 or (len(valide_value) > 0  and int(valide_value[-1],16) == ct_pos):

                    bk = block_search_byte(size_block, i, ct_pos, valide_value) 
                    bp = cipher_block[block-1]
                    bc = block_padding(size_block, i) 

                    tmp = hex_xor(bk,bp)
                    cb  = hex_xor(tmp,bc).upper()

                    up_cipher  = cb + cipher_block[block]
                    #time.sleep(0.5)

                    # we call the oracle, our god
                    response = call_oracle(up_cipher,process)
                    exe = re.findall('..',cb)
                    discover = ('').join(exe[size_block-i:size_block])
                    current =  ('').join(exe[size_block-i-1:size_block-i])
                    find_me =  ('').join(exe[:-i-1])

                    sys.stdout.write("\r[+] Test [Byte %03i/256 - Block %d ]: \033[31m%s\033[33m%s\033[36m%s\033[0m" % (ct_pos, block, find_me, current, discover))
                    sys.stdout.flush()

                    if response:

                        found = True
                        
                        # data analyse and insert in rigth order
                        value = re.findall('..',bk)
                        valide_value.insert(0,value[size_block-(i+1)])

                        print ''
                        print "[+] Block M_Byte : %s"% bk
                        print "[+] Block C_{i-1}: %s"% bp
                        print "[+] Block Padding: %s"% bc
                        print ''

                        bytes_found = ''.join(valide_value)
                        if i == 0 and bytes_found.decode("hex") > hex(size_block) and block == len(cipher_block)-1:
                            print "[-] Error decryption failed the padding is > "+str(size_block)
                            sys.exit()

                        print '\033[36m' + '\033[1m' + "[+]" + '\033[0m' + " Found", i+1,  "bytes :", bytes_found
                        print ''

                        break 
            if found == False:
                # lets say padding is 01 for the last byte of the last block (the padding block)
                if len(cipher_block)-1 == block and i == 0:
                    value = re.findall('..',bk)
                    valide_value.insert(0,"01")
                    print ''
                    print '[-] No padding found, but maybe the padding is length 01 :)'
                    print "[+] Block M_Byte : %s"% bk
                    print "[+] Block C_{i-1}: %s"% bp
                    print "[+] Block Padding: %s"% bc
                    print ''
                    bytes_found = ''.join(valide_value)
                else:
                    print "\n[-] Error decryption failed"
                    result.insert(0, ''.join(valide_value))
                    hex_r = ''.join(result)
                    print "[+] Partial Decrypted value (HEX):", hex_r.upper()
                    padding = int(hex_r[len(hex_r)-2:len(hex_r)],16)
                    print "[+] Partial Decrypted value (ASCII):", hex_r[0:-(padding*2)].decode("hex")
                    sys.exit()
            found = False

        result.insert(0, ''.join(valide_value))
        valide_value = []

    print ''
    hex_r = ''.join(result)
    print "[+] Decrypted value (HEX):", hex_r.upper()
    padding = int(hex_r[len(hex_r)-2:len(hex_r)],16)
    print "[+] Decrypted value (ASCII):", hex_r[0:-(padding*2)].decode("hex")

if __name__ == '__main__':                           
    p = remote("offsec-chalbroker.osiris.cyber.nyu.edu", "1478")
    print p.recvuntil(":")
    p.sendline("jd3846")
    print "jd3846"
    IV = '7dc4885cc38ef6fd0181b78f8f484873'
    Ciphertext =  'f4a60fdec121df64f0dca2abcb8cb82507b20ee6da804da255714b7b588329b8523b9f8664594bdf2437376d5e0f6fc1f913d17b0fc74e5c7be38e3d356a97282bc356e9042cc9d3592df36d45eacd0ed9ba93b2f0ca110d629de3d80b0ad2b9d1be2b6ccf8fc51afbef6d6a75845bbea9e00ee6f0dd6368dd2542963c3e4f47f141a2a9cd22cf85d94edbb18c662c3a67e7872013e700831478962319b5922c007d8909b550e6b1caac8852e1958a38430eedcf16a8a1b7e1050d6fe54f9bfa72d2baf25c6f4b2684ad2553e76cab91fe51e062fc1e9e19d9f5b78966fb2e88e22bb5e51864014a40ca4d49cd6bc112b0d1d876ab690431badb524ea41b6f0d2382fcf01255cea1a41cedde3e98550a7f7e85bce31101fec777c9a65b02db4ae5b66ef1df001f850cef39b7d854776992c7cf271c63537dafcda755e3b92d7303fdbe3fe947ae94f2f997c40f8934d8408205c301d4bf54ad17531d14a2d117535d2a043f4024de8c88d4d508f3a5ebadff5b4b0f188037e8101c2e9b1503a51d50a987eae70277815ed36ef05cc98ccd64954062598913fce924e962d45d8b920e8d490370c50d0d15eccb1057a4ef7464bbdd8ef931d8e903ce24bd6ce13ad2c14b8f137a221ff208810abb6e8bb9d1ff531cd2b4d933b45fd50b14a7d34a96f857c5bf8a765baf8a952b5b039021f9e4567ecca3775c2c49b8ca14e546b61b9af0a76ac0cd468a7a98532c9b2236281918ef13ed2e0e0476e4fc11f6c6e2314a688829467e26c09bd2e00a63fe9301d2944ae7e851eeb32458ce93cf2d8b393545c05f33b7f31b5c825d51cd6214b9e5dfd7583a1bca008a6e688093c2b07b739a81d47d857db951e022ce71e2f78ff83b9e52418b60ea87ed6d69a096896df70d1bd5e9c6bbd3916b6252868fb75ac2850799fce025ce06edd0ae323676fc46b3e41758a8344cb22665efb1691401884d5d21400bdd68663b8d141bb4cb86893ef0500fdc252f8b06383984a88fe7a5f7eecdfa9e1cc756ebd19fa776fed7e8a1cad4974bb51b428cb2db12a772f055836bacf6cd3106c2818d6ded043f13c602367eed8383919b854b35e5357a59114d9b9300fccafb2280bc13c4a2ca474bca400a28806d7286b521b19338b555aae12e4b7f38609132f4fe55bc630024a0897170fc7b1a408cd1e5d4616d69ea41f3912fe3f2bcbf552919cc82bad6fd809d2da66235631d6230b6dec03933075582b2371097c5cb0f731c37031844cd4aff9fc2e9477dc7d9351498f061b828189056401dedb830cb36ff49015aede59da18939ae4d09bf166fbf6c571ebe'
    cipher = IV + Ciphertext
    run(cipher, 16, p)
